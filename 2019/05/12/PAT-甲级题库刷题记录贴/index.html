<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="PAT,">










<meta name="description" content="2019.5.12 柳神推荐的甲级题库刷题方法：PAT甲级共155道题目  ##”树的遍历” ###题目集合 1151、1147、1138、1127、1119、1115、1106、1102、1094、1090、1086、1079、1076、1053、1020、1004 踩坑记录A1020Tree Traversals1.判断左右子树是否为空，不能用”!root-&amp;gt;lchild”，只能用”ro">
<meta name="keywords" content="PAT">
<meta property="og:type" content="article">
<meta property="og:title" content="[PAT]甲级题库刷题记录贴">
<meta property="og:url" content="http://yoursite.com/2019/05/12/PAT-甲级题库刷题记录贴/index.html">
<meta property="og:site_name" content="xuekedou">
<meta property="og:description" content="2019.5.12 柳神推荐的甲级题库刷题方法：PAT甲级共155道题目  ##”树的遍历” ###题目集合 1151、1147、1138、1127、1119、1115、1106、1102、1094、1090、1086、1079、1076、1053、1020、1004 踩坑记录A1020Tree Traversals1.判断左右子树是否为空，不能用”!root-&amp;gt;lchild”，只能用”ro">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/05/12/PAT-甲级题库刷题记录贴/PAT甲级刷题方法.png">
<meta property="og:updated_time" content="2019-05-23T09:24:17.425Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[PAT]甲级题库刷题记录贴">
<meta name="twitter:description" content="2019.5.12 柳神推荐的甲级题库刷题方法：PAT甲级共155道题目  ##”树的遍历” ###题目集合 1151、1147、1138、1127、1119、1115、1106、1102、1094、1090、1086、1079、1076、1053、1020、1004 踩坑记录A1020Tree Traversals1.判断左右子树是否为空，不能用”!root-&amp;gt;lchild”，只能用”ro">
<meta name="twitter:image" content="http://yoursite.com/2019/05/12/PAT-甲级题库刷题记录贴/PAT甲级刷题方法.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/12/PAT-甲级题库刷题记录贴/">





  <title>[PAT]甲级题库刷题记录贴 | xuekedou</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xuekedou</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/PAT-甲级题库刷题记录贴/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xuekedou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xuekedou">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[PAT]甲级题库刷题记录贴</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-12T13:34:42+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>2019.5.12</p>
<p><strong>柳神推荐的甲级题库刷题方法：</strong>PAT甲级共155道题目</p>
<p><img src="/2019/05/12/PAT-甲级题库刷题记录贴/PAT甲级刷题方法.png" alt></p>
<p>##”树的遍历”</p>
<p>###题目集合</p>
<p><del>1151</del>、<del>1147</del>、<del>1138</del>、<del>1127</del>、<del>1119</del>、<del>1115</del>、<del>1106</del>、1102、1094、1090、1086、1079、1076、<del>1053</del>、<del>1020</del>、1004</p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h4 id="A1020Tree-Traversals"><a href="#A1020Tree-Traversals" class="headerlink" title="A1020Tree Traversals"></a>A1020<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072" target="_blank" rel="noopener">Tree Traversals</a></h4><p>1.判断左右子树是否为空，不能用”!root-&gt;lchild”，只能用”root-&gt;lchild != NULL”</p>
<p>2.层序遍历中最后不要空格，通过”计数”来实现格式控制</p>
<p>####A1053<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512" target="_blank" rel="noopener">Path of Equal Weight</a></p>
<p>1.主要是DFS函数的编写，依据“sum与S”的三种关系进行处理，在”sum==S”的情况中要注意是否遍历到叶子结点的判断。</p>
<h4 id="A1151LCA-in-a-Binary-Tree"><a href="#A1151LCA-in-a-Binary-Tree" class="headerlink" title="A1151LCA in a Binary Tree"></a>A1151<a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856" target="_blank" rel="noopener">LCA in a Binary Tree</a></h4><p>1.已知中序与先序、后序、层序任意一种建树，注意临时的根节点申明为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node* root = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>
<p>2.已知中序遍历与先序遍历构建树的简便方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中inl与inr为中序遍历的左端元素和右端元素</span></span><br><span class="line"><span class="comment">//preRoot为先序遍历中root结点在pre[]中的序号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> inl,<span class="keyword">int</span> inr,<span class="keyword">int</span> preRoot,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="comment">//输入中序遍历序列的时候记录"输入的序号i"</span></span><br><span class="line"><span class="comment">//引入pos[]数组的这个技巧很巧妙</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">        pos[in[i]] = i;<span class="comment">//记录原输入顺序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="A1147Heaps"><a href="#A1147Heaps" class="headerlink" title="A1147Heaps"></a>A1147<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">Heaps</a></h4><p><strong>1.</strong>层序遍历数组[0…n-1]中，父结点序号和左右子结点序号的关系：left=parentX2+1;right=parentX2+2</p>
<p>若为[1…n]中，父结点序号和左右子结点序号的关系：left=parentX2;right=parentX2+1</p>
<p><strong>2.</strong>不用构建树的话，直接pre.resize(n),不用pre.resize(n+1);</p>
<p><strong>3.</strong>后序遍历的递归写法-注意格式的控制技巧</p>
<p>root==0的时候说明输出到最后一个数，则换行；否则只输出空格</p>
<h4 id="A1138Postorder-Traversal"><a href="#A1138Postorder-Traversal" class="headerlink" title="A1138Postorder Traversal"></a>A1138<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200" target="_blank" rel="noopener">Postorder Traversal</a></h4><p>1.由遍历序列建树，找出根节点在中序遍历中的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=inL;i&lt;=inR;i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2.已知前序和中序，求后序-熟悉简单写法，抛弃算法笔记的复杂写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数只需要prel,inl,inr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> prel,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归主体</span></span><br><span class="line">    <span class="keyword">int</span> i = inl;</span><br><span class="line">    <span class="keyword">while</span>(in[i]!=pre[prel]) i++;</span><br><span class="line">    postOrder(prel+<span class="number">1</span>,inl,i<span class="number">-1</span>);</span><br><span class="line">    postOrder(prel+i-inl+<span class="number">1</span>,i+<span class="number">1</span>,inr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="A1127ZigZagging-on-a-Tree"><a href="#A1127ZigZagging-on-a-Tree" class="headerlink" title="A1127ZigZagging on a Tree"></a>A1127<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805349394006016" target="_blank" rel="noopener">ZigZagging on a Tree</a></h4><p>1.建树-需要记录节点层数的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点的结构-不用左右子结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index,depth;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过二维数组表示法表示一棵树</span></span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">35</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment">//建树办法</span></span><br><span class="line"><span class="comment">//多了一个index参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;index,<span class="keyword">int</span> inLeft,<span class="keyword">int</span> inRight,<span class="keyword">int</span> postLeft,<span class="keyword">int</span> postRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(inLeft &gt; inRight) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归主体</span></span><br><span class="line">    index = postRight;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(in[i]!=post[postRight]) i++;</span><br><span class="line">    dfs(tree[index][<span class="number">0</span>],inLeft,i<span class="number">-1</span>,postLeft,postLeft+(i-inLeft)<span class="number">-1</span>); </span><br><span class="line">    dfs(tree[index][<span class="number">1</span>],i+<span class="number">1</span>,inRight,postLeft+(i-inLeft),postRight<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="A1119Pre-and-Post-order-Traversals"><a href="#A1119Pre-and-Post-order-Traversals" class="headerlink" title="A1119Pre- and Post-order Traversals"></a>A1119<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805353470869504" target="_blank" rel="noopener">Pre- and Post-order Traversals</a></h4><p>1.判断树是否唯一的依据——一个结点可能是根的左孩子也可能是根的右孩子——找左子树和右子树的根结点，如果相同，则不唯一，假设为右子树根结点；如果不相同，则唯一，继续递归建树</p>
<p>注意：递归边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preLeft==preRight)</span><br><span class="line">    &#123;</span><br><span class="line">        in.push_back(pre[preLeft]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre[preLeft]==post[postRight])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=preLeft+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在先序遍历中找右子树的根节点</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=preRight &amp;&amp; pre[i]!=post[postRight<span class="number">-1</span>]) i++;</span><br><span class="line">        <span class="comment">//可以区分左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(i-preLeft&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            getIn(preLeft+<span class="number">1</span>,i<span class="number">-1</span>,postLeft,postLeft+(i-preLeft<span class="number">-1</span>)<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不唯一</span></span><br><span class="line">            <span class="comment">//右子树根节点和左子树根结点相同，无法判断是左子树还是右子树</span></span><br><span class="line">            unique = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当不唯一的时候，假设为右子树根结点</span></span><br><span class="line">        in.push_back(post[postRight]);</span><br><span class="line">        getIn(i,preRight,postLeft+(i-preLeft<span class="number">-1</span>),postRight<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="A1115Counting-Nodes-in-a-BST"><a href="#A1115Counting-Nodes-in-a-BST" class="headerlink" title="A1115Counting Nodes in a BST"></a>A1115<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805355987451904" target="_blank" rel="noopener">Counting Nodes in a BST</a></h4><p>1.递归建树的递归边界先写好”return”，不管有没有其他语句，非常容易忽略</p>
<p>2.BST建树的递归模板-思路：输入一个值，插入一个结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归建树-BST-可作为模板</span></span><br><span class="line"><span class="comment">//参数要记住：根节点指针和插入的值</span></span><br><span class="line"><span class="function">node* <span class="title">build</span><span class="params">(node* root,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">        root-&gt;data = v;</span><br><span class="line">        root-&gt;lchild = root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v&lt;=root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;lchild = build(root-&gt;lchild,v);</span><br><span class="line">    &#125;<span class="keyword">else</span><span class="comment">//相等值放在右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;rchild = build(root-&gt;rchild,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.连续定义两个指针变量，*的位置要变化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *lchild,*rchild;<span class="comment">//同时定义两个，则*号要放在变量名前面</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.DFS方法记录一棵树对应层数中的结点数——思路：声明一个二维数组num[]</p>
<p>####A1106<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805362341822464" target="_blank" rel="noopener">Lowest Price in Supply Chain</a></p>
<p>1.树以邻接表的形式存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点个数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100005</span>];</span><br></pre></td></tr></table></figure>
<p>2.根据题目要求的两个限制条件——深度最小、叶子结点——写出判断条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界-不符合深度最小</span></span><br><span class="line">    <span class="keyword">if</span>(mindepth &lt; depth)&#123;&#125;</span><br><span class="line">    <span class="comment">//叶子结点-retailer</span></span><br><span class="line">    <span class="keyword">if</span>(v[index].size()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mindepth == depth)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mindepth &gt; depth)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[index].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(v[index][i],depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="A1102-Invert-a-Binary-Tree"><a href="#A1102-Invert-a-Binary-Tree" class="headerlink" title="A1102 Invert a Binary Tree"></a>A1102 <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805365537882112" target="_blank" rel="noopener">Invert a Binary Tree</a></h4><p>1.Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
<p>2.翻转二叉树的基本思想：在存储的时候所有左右结点都交换——使用RNL的遍历方式即可反转二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> index,<span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//RLN-逆中序遍历-可以反转二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(a[root].r!=<span class="number">-1</span>) dfs(a[root].r,index*<span class="number">2</span>+<span class="number">2</span>,level+<span class="number">1</span>);</span><br><span class="line">    v1.push_back(&#123;root,<span class="number">0</span>,<span class="number">0</span>,index,level&#125;);</span><br><span class="line">    <span class="keyword">if</span>(a[root].l!=<span class="number">-1</span>) dfs(a[root].l,index*<span class="number">2</span>+<span class="number">1</span>,level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.根结点是所有左右结点中没有出现的那个结点</p>
<h4 id="A1094The-Largest-Generation"><a href="#A1094The-Largest-Generation" class="headerlink" title="A1094The Largest Generation"></a>A1094<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805372601090048" target="_blank" rel="noopener">The Largest Generation</a></h4><p>1.找出包含结点最多的那层，并输出层数和该层的结点总数</p>
<p>2.根据输入以邻接表表示树 + BFS统计每层的结点数 + 输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表表示树v[index][i]</span></span><br><span class="line"><span class="comment">//100个结点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计某结点的层数 以及 某层的结点总数</span></span><br><span class="line"><span class="keyword">int</span> level[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<h4 id="A1090Highest-Price-in-Supply-Chain"><a href="#A1090Highest-Price-in-Supply-Chain" class="headerlink" title="A1090Highest Price in Supply Chain"></a>A1090<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805376476626944" target="_blank" rel="noopener">Highest Price in Supply Chain</a></h4><p>1.邻接表存储树 + 最大层数以及最大层数的结点数</p>
<p>2.each number Si is the index of the supplier for the i-th member. Sroot for the root supplier is defined to be −1.——Si是i的父节点，Sroot是根结点</p>
<p>3.关键的dfs代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//叶子结点-retailer</span></span><br><span class="line">    <span class="keyword">if</span>(v[index].size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相等</span></span><br><span class="line">        <span class="keyword">if</span>(maxDepth == depth)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更大</span></span><br><span class="line">        <span class="keyword">if</span>(maxDepth &lt; depth)</span><br><span class="line">        &#123;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">            maxNum = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//更小</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是retailer</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[index].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(v[index][i],depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.r%在输出的时候要注意”r/100”</p>
<h4 id="A1086Tree-Traversals-Again"><a href="#A1086Tree-Traversals-Again" class="headerlink" title="A1086Tree Traversals Again"></a>A1086<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024" target="_blank" rel="noopener">Tree Traversals Again</a></h4><p>1.<strong>栈的形式给出一棵二叉树的建立过程</strong>-(1) 栈pop输出的顺序的中序遍历(左根右) (2) 栈push输入的顺序是二叉树的前序遍历(根左右)——实际上是前序+中序-&gt;后序</p>
<p>2.题目没有说树中的结点值全部不相同——前中后序存储索引值，value数组中存储具体的值，因为索引值一定是不相同的。</p>
<h4 id="A1079Total-Sales-of-Supply-Chain"><a href="#A1079Total-Sales-of-Supply-Chain" class="headerlink" title="A1079Total Sales of Supply Chain"></a>A1079<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805388447170560" target="_blank" rel="noopener">Total Sales of Supply Chain</a></h4><p>1.统计所有叶子的层数</p>
<h4 id="A1076Forwards-on-Weibo"><a href="#A1076Forwards-on-Weibo" class="headerlink" title="A1076Forwards on Weibo"></a>A1076<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736" target="_blank" rel="noopener">Forwards on Weibo</a></h4><p>1.待做</p>
<h4 id="A1004Counting-Leaves"><a href="#A1004Counting-Leaves" class="headerlink" title="A1004Counting Leaves"></a>A1004<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184" target="_blank" rel="noopener">Counting Leaves</a></h4><p>1.待做</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PAT/" rel="tag"># PAT</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/11/电影-何以为家/" rel="next" title="[电影]何以为家">
                <i class="fa fa-chevron-left"></i> [电影]何以为家
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/13/NBA-卡哇伊抢七绝杀/" rel="prev" title="[NBA]卡哇伊抢七绝杀">
                [NBA]卡哇伊抢七绝杀 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xuekedou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xuekedou" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#踩坑记录"><span class="nav-number">1.</span> <span class="nav-text">踩坑记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A1020Tree-Traversals"><span class="nav-number">1.1.</span> <span class="nav-text">A1020Tree Traversals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1151LCA-in-a-Binary-Tree"><span class="nav-number">1.2.</span> <span class="nav-text">A1151LCA in a Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1147Heaps"><span class="nav-number">1.3.</span> <span class="nav-text">A1147Heaps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1138Postorder-Traversal"><span class="nav-number">1.4.</span> <span class="nav-text">A1138Postorder Traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1127ZigZagging-on-a-Tree"><span class="nav-number">1.5.</span> <span class="nav-text">A1127ZigZagging on a Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1119Pre-and-Post-order-Traversals"><span class="nav-number">1.6.</span> <span class="nav-text">A1119Pre- and Post-order Traversals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1115Counting-Nodes-in-a-BST"><span class="nav-number">1.7.</span> <span class="nav-text">A1115Counting Nodes in a BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1102-Invert-a-Binary-Tree"><span class="nav-number">1.8.</span> <span class="nav-text">A1102 Invert a Binary Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1094The-Largest-Generation"><span class="nav-number">1.9.</span> <span class="nav-text">A1094The Largest Generation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1090Highest-Price-in-Supply-Chain"><span class="nav-number">1.10.</span> <span class="nav-text">A1090Highest Price in Supply Chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1086Tree-Traversals-Again"><span class="nav-number">1.11.</span> <span class="nav-text">A1086Tree Traversals Again</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1079Total-Sales-of-Supply-Chain"><span class="nav-number">1.12.</span> <span class="nav-text">A1079Total Sales of Supply Chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1076Forwards-on-Weibo"><span class="nav-number">1.13.</span> <span class="nav-text">A1076Forwards on Weibo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1004Counting-Leaves"><span class="nav-number">1.14.</span> <span class="nav-text">A1004Counting Leaves</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuekedou</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">20.3k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
